## 例子

对下面每个结构声明，确定每个字段的偏移量、结构总的大小，以及在x86-64下它的对齐要求：

A. struct P1{int i; char c; int j; char d;};

B. struct P2{int i; char c; char d; long j;};

C. struct P3{short w[3]; char c[3];};

D. struct P4{short w[5]; char* c[3];};

E. struct P5{struct P3 a[2]; struct P2 t;};


## 分析
假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果保证所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值。

否则，我们可能需要执行两次内存访问，因为对象可能被放在两个8字节内存块中。无论数据是否对齐，x86-64都能正常工作。对齐原则是**任何K字节的基本对象的地址必须是K的倍数**。

## 结论
- A

|i|c|j|d|总共|对齐|
|:--:|:--:|:--:|:--:|:--:|:--:|
|0|4|8|12|16|4|

![20201210a](/images/20201210a.png)

- B

|i|c|d|j|总共|对齐|
|:--:|:--:|:--:|:--:|:--:|:--:|
|0|4|5|8|16|8|

![20201210b](/images/20201210b.png)

- C

|w|c|总共|对齐|
|:--:|:--:|:--:|:--:|
|0|6|10|2|

![20201210c](/images/20201210c.png)

> 注意，在此处填充了一个额外的字节，是为了保持边界对齐。

- D

|w|c|总共|对齐|
|:--:|:--:|:--:|:--:|
|0|16|40|8|

- E

|a|t|总共|对齐|
|:--:|:--:|:--:|:--:|
|0|24|40|8|

## 一种计算对齐方式的函数

```cpp
#define SKB_DATA_ALIGN(X)    (((X) + (SMP_CACHE_BYTES - 1)) & \
                             ~(SMP_CACHE_BYTES - 1))
```
另 `SMP_CACHE_BYTES - 1` 为 `mask` 则上面的宏定义简化成 `（x + mask）& （～mask）`，

首先加上 `mask` 使得不够 `SMP_CACHE_BYTES` 的部分先补齐，然后 `& ～mask` 其实就是把数据不足 `SMP_CACHE_BYTES` 的部分清除掉。

比如 `SMP_CACHE_BYTES = 4 （100）`，那 么 `mask = 3 （011）`。

假设 `x = 3`，那么最后的结果是 `110（6 = 3 + 3）& 100（～3）= 100（4）`。

假设 `x = 1`，那么结果就是 `100（4 = 1 + 3） & 100 （～3） = 100（4）`。

假 设 `x= 5` ，那么最后的结果是 `1000（8 = 5 + 3） &（1100） = 1000（8）`。

假设 `x = 7`， 那么结果是 `1010（10 = 7 + 3） & 1100（～3） = 1000 （8）`。

## 参考文献
1. Randal E.Bryant, David O’Hallaron. [深入理解计算机系统(第2版). 机械工业出版社, 2010](https://book.douban.com/subject/5333562/)
