## 参考资料:
- 一个典型的ELF可重定位目标文件包含下面几个节：

| 类型 | 功能及含义 |
|:-|:-|
| .text | 已编译程序的机器代码。|
| .rodata | 只读数据，比如printf语句中的格式传和开关语句的跳转表。|
| .data | **已初始化的全局和静态C变量**。局部C变量在运行时被保存在栈中，即不出现在.data节中，也不出现在.bss节中。|
| .bss（Block Storage Start或者Better Save Space）| **未初始化的全局和静态C变量，以及所有被初始化为0的全局或者静态变量**。在目标文件中，这个节不占据实际空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。|
| .symtab | 一个符号表，它存放在程序中定义和引用的函数和全局变量信息。一些程序员错误的认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表（除非程序员特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。|
| .rel.text | 一个.text节中位置的列表，当链接器把这个目录文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。|
| .debug | 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。|
| .line | 原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译器驱动程序时，才会得到这张表。|
| .strtab | 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。|

- 重定位是将EFL文件中的**未定义符号关联到有效值**的处理过程。

- **对用户空间程序符号的替换，内核并不涉及其中**，因为所有的替换操作都是由外部工具完成的。对内核模块来说，情况有所不同，因为内核所收到的模块裸数据，与其存储在二级制文件中的形式完全相同，内核本身需要负责重定位操作。

- 在每个目标文件中，都有一个专门的表，包含了重定位项，标识了需要进行重定位之处。每个表项都包含下列信息：

	1. 一个偏移量，指定了修改的项的位置。
	
	2. 对符号的引用（符号表的索引），提供了需要插入到重定位位置的数据。

- 重定位步骤
	
	1. 重定位节和符号定义。
	
		- 链接器将所有相同类型的节合并为同一类型的新的聚合节。例如来自输入模块的.data节全部合并成一个节，这个节成为输出可执行目标文件的.data节。然后链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。
		
	2. 重定位节中的符号引用。
	
		- 在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的运行时地址。为了执行这一步，链接器依赖于称之为重定位条目的可重定位目标模块中的数据结构。

- 重定向条目

	- 当汇编器生成一个目标模块时，它并不知道数据和代码最终将存放在存储器中的什么位置。它也不知道这个模块引用的任何外部定义的函数和全局变量。所以，无论何时汇编器遇到对最终位置未指定目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并可执行文件时如何修改这个引用。代码重定位条目放在.rel.text中。已经初始化数据的重定位条目放在.rel.data中。

- 数据结构
```c
typedef struct
{
	long	offset;				/* Offsetof the reference to relocate */
	long	type:32,			/* Relocation type */
			symbol:32;			/* Symbol table index */
	long	addend;				/* Constant part of relocation expression */加数，计算重定位是，将根据重定位类型，对该值进行不同的处理。

} Elf64_Rela;
```

- 重定位类型

ELF定义了很多重定位类型，关心其中两种最基本的重定位类型：
	
1. R_X86_64_PC32(相对重定位)。

2. R_X86_64_32(绝对重定位)。

## 举例说明：

有以下3个源文件，其中a.c：
```c
int sum(int a, int b)
{
	return a + b;
}
```
b.c
```c
int mul(int a, int b)
{
	return a * b;
}
```
main.c
```c
#include <stdio.h>
int a = 12;
int main()
{
	int b = 12;
	printf("a + b = %d\n", sum(a, b));
	printf("a * b = %d\n", mul(a, b));
	return 0;
}
```
分别用以下命令生成`a.o`, `b.o`, `main.o`可重定向文件

![2021010801](/images/2021010801.png)

> 注，报warning是因为main.c文件中sum和mul两个符号是隐式声明，源文件并没有用include去引用a.c和b.c文件，对这两个符号解析留给链接阶段。

用以下命令链接生成`main`可执行文件

![2021010801](/images/2021010802.png)

> 注，此时main.o中sum和mul两个符号是依赖于a.o和b.o的，在此链接阶段需要对这两个符号解析。

因为a.c和b.c没有外部引用，所以在.o文件中不存在重定位表项，只有main.o存在，如下：

![2021010803](/images/2021010803.png)

![2021010804](/images/2021010804.png)

从main.c源文件也不难看出，它引用了外面sum和mul符号，并且引用了一个全局a符号。并且从上图也可以看出。

并且可以得到：

1. a第一处offset ： 0x11 重定位的字节处 并且从第二幅图可以得知a的大小为4个字节
	
2. a第二处offset ： 0x3b

3. sum offset    ： 0x22
	
4. mul offset    ： 0x4c
	
计算a的重定位后的地址：根据公式：S + A

S为目标文件符号表中的对应的地址（为什么不是.o文件呢，因为.o文件的符号表中的地址都是重定位REL类型，都为0）：

![2021010805](/images/2021010805.png)

可以得到S(a) = 0x201010，接下来要确定加值A，这要看main.o 的汇编代码了，利用objdump来查看该.text节的汇编代码：

![2021010806](/images/2021010806.png)

0x11后面的4个字节的位置，其后0x00000000=0所有加值为0，则Result=0x201010+0=0x201010，也就是目标文件的0x11后面的后4个字节要被替换为该值。现在我们验证一下：

从图中可以看出，在0x11(对应05)开始后的4个字节为20 10 10（对a本应为绝对寻址，但RIP相对寻址0x2009b1的内容就是20 10 10，**RIP存的就是PC**）。

![2021010808](/images/2021010808.png)

相对重定位的计算：

以sum为例（由前面的截图和计算可以得知offset=0x22）：

![2021010807](/images/2021010807.png)

S(sum) = 0x06b4;

A(sum)= 0x00000000（此处为何不是0xfffffffc,导致对Result少减4）;

P(sum)= 0x066b+1(操作指令一个字节) = 0x066c --运行时地址

Result= S + A - P = 0x06b4 + 0 - 0x066c = 0x48（实际是0x44）。

如图e8之后是00 00 00 44（小端）。

在运行时，call指令将放在0x066b处，当cpu执行call指令时，pc的值为0x066b + 1 + 4 = 0x0670，即紧随着call指令之后的指令的地址。为了执行这条指令，cpu执行以下的步骤：

1. push PC onto stack

2. PC <- PC + 0x44 = 0x0670 + 0x44 =  0x06b4

该地址恰好是sum的第一条指令的地址。

![2021010809](/images/2021010809.png)

## 参考文献
1. Randal E.Bryant, David O’Hallaron. [深入理解计算机系统(第2版). 机械工业出版社, 2010](https://book.douban.com/subject/5333562/)
